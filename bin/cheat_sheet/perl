# list of cool features
https://stackoverflow.com/questions/161872/hidden-features-of-perl

# print specific columns from a tabulated files
#!/usr/bin/perl -wnla

BEGIN { @f = ('id', 'age'); print "@f"; }
if ($. == 1) { @n = @F; } else { @v{@n} = @F; print "@v{@f}"; }


https://metacpan.org/pod/Cache::FastMmap


#stderr in red
use Text::OutputFilter;
use Term::ANSIColor;
tie *STDERR, "Text::OutputFilter", 0, *STDERR, sub { color ("red")."$_[0]".color ("reset") } ;


Perl Simple Webserver
perl -MIO::All -e 'io(":8080")->fork->accept->(sub { $_[0] < io(-x $1 ? "./$1 |" : $1) if /^GET \/(.*) / })'

First we accept a socket and fork the server. Then we overload the new socket as a code ref. This code ref takes one argument, another code ref, which is used as a callback. The callback is called once for every line read on the socket. The line is put into $_ and the socket itself is passed in to the callback. Our callback is scanning the line in $_ for an HTTP GET request. If one is found it parses the file name into $1. Then we use $1 to create an new IO::All file object... with a twist. If the file is executable("-x"), then we create a piped command as our IO::All object. This somewhat approximates CGI support. Whatever the resulting object is, we direct the contents back at our socket which is in $_[0].
